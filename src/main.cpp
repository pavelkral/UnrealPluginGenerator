#include <iostream>
#include <fstream>
#include <string>
#include <algorithm>
#include <locale>

#ifdef _WIN32
#include <direct.h>
#define MKDIR(path) _mkdir(path)
#else
#include <sys/stat.h>
#define MKDIR(path) mkdir(path, 0777)
#endif


std::string toUpperByChar(const std::string& str) {
    std::string upperStr;
    std::locale loc;
    for (char c : str) {
        upperStr += std::toupper(c, loc);
    }
    return upperStr;
}

std::string toUpper(const std::string& str) {
    std::string upperStr = str;
    std::transform(upperStr.begin(), upperStr.end(), upperStr.begin(), ::toupper);
    return upperStr;
}

bool CreateDirectory(const std::string& path)
{
    if (MKDIR(path.c_str()) != 0) {
        std::cerr << "Failed to create directory: " << path << std::endl;
        return false;
    }
    return true;
}

bool GeneratePlugin(const std::string& PluginName, const std::string& ClassName, const std::string& AuthorName)
{
    std::string BaseDirectory = "./";
   // std::string BaseDirectory = "D:/_Dev/";

    // Create plugin directory
    std::string PluginDirectory = BaseDirectory + PluginName + "/";
    if (!CreateDirectory(PluginDirectory)) {
        std::cerr << "Failed to create plugin directory.\n";
       // return false;
    }
   // std::cout << PluginDirectory;

    std::string SourceDirectory = PluginDirectory + "Source/";
   // std::cout << SourceDirectory << std::endl;

    if (!CreateDirectory(SourceDirectory)) {
        std::cerr << "Failed to create source directory.\n";
       // return false;
    }
    std::string ContentDirectory = PluginDirectory + "Content/";
    // std::cout << SourceDirectory << std::endl;

    if (!CreateDirectory(ContentDirectory)) {
        std::cerr << "Failed to create content directory.\n";
        // return false;
    }
    std::string ResourcesDirectory = PluginDirectory + "Resources/";
    // std::cout << SourceDirectory << std::endl;

    if (!CreateDirectory(ResourcesDirectory)) {
        std::cerr << "Failed to create resources directory.\n";
        // return false;
    }


      std::string SourceFileDirectory = PluginDirectory + "Source/" + PluginName + "/";
   // std::cout << SourceDirectory << std::endl;

    if (!CreateDirectory(SourceFileDirectory)) {
        std::cerr << "Failed to create source file directory.\n";
       // return false;
    }
    std::string PublicSourceFileDirectory = PluginDirectory + "Source/" + PluginName + "/Public/";
    // std::cout << SourceDirectory << std::endl;

    if (!CreateDirectory(PublicSourceFileDirectory)) {
        std::cerr << "Failed to create public source directory.\n";
        // return false;
    }
    std::string PrivateSourceFileDirectory = PluginDirectory + "Source/" + PluginName + "/Private/";
    // std::cout << SourceDirectory << std::endl;

    if (!CreateDirectory(PrivateSourceFileDirectory)) {
        std::cerr << "Failed to create private source directory.\n";
        // return false;
    }
 
 

    std::string PluginFile = PluginDirectory + PluginName + ".uplugin";
    std::string BuildCsFile = SourceFileDirectory + PluginName + ".Build.cs";
    std::string ActorHeaderFile = PublicSourceFileDirectory  + PluginName + "Actor.h";
    std::string ActorCppFile = PrivateSourceFileDirectory  + PluginName + "Actor.cpp";

    std::string ClassHeaderFile = PublicSourceFileDirectory + PluginName + ".h";
    std::string ClassCppFile = PrivateSourceFileDirectory + PluginName + ".cpp";

    // Plugin File
    {
        std::ofstream PluginFileOut(PluginFile);
        if (!PluginFileOut) {
            std::cerr << "Failed to create plugin file.\n";
            return false;
        }
        PluginFileOut << "{\n";
        PluginFileOut << "	\"FileVersion\": 3,\n";
        PluginFileOut << "	\"Version\": \"1.0\",\n";
        PluginFileOut << "	\"VersionName\": \"1.0\",\n";
        PluginFileOut << "	\"FriendlyName\": \"" << PluginName << "\",\n";
        PluginFileOut << "	\"Description\": \"Unreal Engine plugin generated by PluginGenerator.\",\n";
        PluginFileOut << "	\"Category\": \"Programming\",\n";
        PluginFileOut << "	\"Installed\": false,\n";
        PluginFileOut << "	\"CanContainContent\": true,\n";
        PluginFileOut << "	\"Modules\": [\n";
        PluginFileOut << "		{\n";
        PluginFileOut << "			\"Name\": \"" << PluginName << "\",\n";
        PluginFileOut << "			\"Type\": \"Runtime\",\n";
        PluginFileOut << "			\"LoadingPhase\": \"Default\",\n";
        PluginFileOut << "			\"WhitelistPlatforms\": [\n";
        PluginFileOut << "				\"Win64\"\n";
        PluginFileOut << "			]\n";
        PluginFileOut << "		}\n";
        PluginFileOut << "	]\n";
        PluginFileOut << "}\n";
    }

    // Build.cs File
    {
        std::ofstream BuildCsFileOut(BuildCsFile);
        if (!BuildCsFileOut) {
            std::cerr << "Failed to create Build.cs file.\n";
            return false;
        }
        BuildCsFileOut << "using UnrealBuildTool;\n";
        BuildCsFileOut << "\n";
        BuildCsFileOut << "public class " << PluginName << " : ModuleRules\n";
        BuildCsFileOut << "{\n";
        BuildCsFileOut << "	public " << PluginName << "(ReadOnlyTargetRules Target) : base(Target)\n";
        BuildCsFileOut << "	{\n";
        BuildCsFileOut << "		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;\n";
        BuildCsFileOut << "\n";
        BuildCsFileOut << "		PublicDependencyModuleNames.AddRange(new string[] { \"Core\", \"CoreUObject\", \"Engine\", \"InputCore\" });\n";
        BuildCsFileOut << "\n";
        BuildCsFileOut << "		PrivateDependencyModuleNames.AddRange(new string[] {  });\n";
        BuildCsFileOut << "\n";
        BuildCsFileOut << "		// Uncomment if you are using Slate UI\n";
        BuildCsFileOut << "		// PrivateDependencyModuleNames.AddRange(new string[] { \"Slate\", \"SlateCore\" });\n";
        BuildCsFileOut << "\n";
        BuildCsFileOut << "		// Uncomment if you are using online features\n";
        BuildCsFileOut << "		// PrivateDependencyModuleNames.Add(\"OnlineSubsystem\");\n";
        BuildCsFileOut << "\n";
        BuildCsFileOut << "		// To include OnlineSubsystemSteam, add it to the plugins section in your uproject file with the Enabled attribute set to true\n";
        BuildCsFileOut << "	}\n";
        BuildCsFileOut << "}\n";
    }

    // Actor Header File
    {
        // Create module header file
        std::ofstream moduleHeaderFile(ClassHeaderFile);
        if (!moduleHeaderFile.is_open()) {
            std::cerr << "Failed to create module header file.\n";
            return false;
        }
        moduleHeaderFile << "#pragma once\n\n";
        moduleHeaderFile << "#include \"CoreMinimal.h\"\n";
        moduleHeaderFile << "#include \"Modules/ModuleManager.h\"\n\n";


        moduleHeaderFile << "class F" << PluginName << "Module : public IModuleInterface\n{\npublic:\n";
        moduleHeaderFile << "    virtual void StartupModule() override;\n";
        moduleHeaderFile << "    virtual void ShutdownModule() override;\n};\n";


        moduleHeaderFile.close();

        // Create module source file
        std::ofstream moduleSourceFile(ClassCppFile);
        if (!moduleSourceFile.is_open()) {
            std::cerr << "Failed to create module source file.\n";
            return false;
        }
        moduleSourceFile << "#include \"" << PluginName << ".h\"\n\n";
        moduleSourceFile << "#define LOCTEXT_NAMESPACE \"F" << PluginName << "Module\"\n\n";
        moduleSourceFile << "void F" << PluginName << "Module::StartupModule()\n{\n}\n\n";
        moduleSourceFile << "void F" << PluginName << "Module::ShutdownModule()\n{\n}\n";
        moduleSourceFile << "\n#undef LOCTEXT_NAMESPACE\n\n";
		moduleSourceFile << "IMPLEMENT_MODULE(F" << PluginName << "Module, " << PluginName << ");\n";
        moduleSourceFile.close();


        std::ofstream ActorHeaderFileOut(ActorHeaderFile);
        if (!ActorHeaderFileOut) {
            std::cerr << "Failed to create actor header file.\n";
            return false;
        }
        ActorHeaderFileOut << "#pragma once\n";
        ActorHeaderFileOut << "\n";
        ActorHeaderFileOut << "#include \"CoreMinimal.h\"\n";
        ActorHeaderFileOut << "#include \"GameFramework/Actor.h\"\n";
        ActorHeaderFileOut << "#include \"" << PluginName << "Actor.generated.h\"\n";
        ActorHeaderFileOut << "\n";
        ActorHeaderFileOut << "UCLASS()\n";
        ActorHeaderFileOut << "class " << toUpper(PluginName) << "_API A" << PluginName << "Actor : public AActor\n";
        ActorHeaderFileOut << "{\n";
        ActorHeaderFileOut << "	GENERATED_BODY()\n";
        ActorHeaderFileOut << "\n";
        ActorHeaderFileOut << "public:	\n";
        ActorHeaderFileOut << "	// Sets default values for this actor's properties\n";
        ActorHeaderFileOut << "	A" << PluginName << "Actor();\n";
        ActorHeaderFileOut << "\n";
        ActorHeaderFileOut << "protected:\n";
        ActorHeaderFileOut << "	// Called when the game starts or when spawned\n";
        ActorHeaderFileOut << "	virtual void BeginPlay() override;\n";
        ActorHeaderFileOut << "\n";
        ActorHeaderFileOut << "public:	\n";
        ActorHeaderFileOut << "	// Called every frame\n";
        ActorHeaderFileOut << "	virtual void Tick(float DeltaTime) override;\n";
        ActorHeaderFileOut << "};\n";
    }

    // Actor CPP File
    {
        std::ofstream ActorCppFileOut(ActorCppFile);
        if (!ActorCppFileOut) {
            std::cerr << "Failed to create actor cpp file.\n";
            return false;
        }
        ActorCppFileOut << "#include \"" << PluginName << "Actor.h\"\n";
        ActorCppFileOut << "\n";
        ActorCppFileOut << "// Sets default values\n";
        ActorCppFileOut << "\n";
        ActorCppFileOut << "A" << PluginName << "Actor::A" << PluginName << "Actor()\n";
        ActorCppFileOut << "{\n";
        ActorCppFileOut << "	// Set this actor to call Tick() every frame\n";
        ActorCppFileOut << "	PrimaryActorTick.bCanEverTick = true;\n";
        ActorCppFileOut << "}\n";
        ActorCppFileOut << "\n";
        ActorCppFileOut << "// Called when the game starts or when spawned\n";
        ActorCppFileOut << "void A" << PluginName << "Actor::BeginPlay()\n";
        ActorCppFileOut << "{\n";
        ActorCppFileOut << "	Super::BeginPlay();\n";
        ActorCppFileOut << "}\n";
        ActorCppFileOut << "\n";
        ActorCppFileOut << "// Called every frame\n";
        ActorCppFileOut << "void A" << PluginName << "Actor::Tick(float DeltaTime)\n";
        ActorCppFileOut << "{\n";
        ActorCppFileOut << "	Super::Tick(DeltaTime);\n";
        ActorCppFileOut << "}\n";
    }

    return true;
}

int main(int argc, char* argv[])
{
    if (argc != 4)
    {
        std::cerr << "Usage: " << argv[0] << " <PluginName> <ClassName>\n";
        return 1;
    }

    std::string PluginName = argv[1];
    std::string ClassName = argv[2];
    std::string ActorName = argv[3];

    if (!GeneratePlugin(PluginName, ClassName, ActorName)) {
        std::cerr << "Failed to generate plugin.\n";
        return 1;
    }

    std::cout << "Unreal Engine plugin '" << PluginName << "' with class '" << ClassName << "' generated successfully.\n";

    return 0;
}